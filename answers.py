# -*- coding: utf-8 -*-
"""answers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A9PmY96g5c3f5coz3JUsLvgBM4jgThG-

# CMPS 6610 Problem Set 01
## Answers

**Name:** Adam Ledet

Place all written answers from `assignment-01.md` here for easier grading.

1. **Asymptotic notation**

  - 1a - Yes. As an example, let us look at every value of n from 1 to infinity, 2^(n+1) ≤ c·2^n. For any c value above 1, we will always get a true statement.

  - 1b - No. As a counter example, let us look at c=5 and every value of n. 2^(2^n) ≤ 5·2^(n). While this is true at n=1 and n=2, at any value of n=3 or larger, the statement is false.

  - 1c - No. Logs are always better performing than any exponent. Let us look at c=10 in this example. n^(1.01) ≤ 10·log(n)^2 for every value of n. At n=1, our results are 1≤0 which is false, but as our n increases, n^1.01 asymptotically dominates c·log(n)^2 and is true at every occurence.

  - 1d - Yes. This is the reverse of the previous problem and asks if n^1.01 asymptotically dominates c·log(n)^2. Any exponent will always outgrow any log.

  - 1e - Yes. Let us look at the example c=2 and n={10, 20, 30} for sqrt(n)≤c·log(n)^3. At n=10, we have 3.16≤2; at n=20, we have 4.47≤4.20; but at n=30, we have 5.48≤6.44. This value will be true at every larger value of n showing asymptotic dominance of the log over our square root function.

  - 1f - No. This is the reverse of the above problem. Using the same values above for c=2 and n={10, 20, 30}, we have 3.16≥2; at n=20, we have 4.47≥4.20; and at n=30, we have 5.48≥6.44. The function begins true but becomes false showing that the square root is asymptotically dominant over the log and not the other way around.

  - 1g - Logically, the intersection of *O* and Ω is the point at which both are equal. Representing *O* as g(n)≤f(n) and Ω as g(n)≥f(n), both statements are only true at THETA when the equations are equal. Our *o* and ω notations can be represented as g(n)<f(n) and g(n)>f(n) respectively. For no real number can a number be both greater and less than another value. If no real number can be the solution, then the only solution is the empty set.

2. **SPARC to Python**

  - 2b - This function takes two inputs and ultimately returns the maximum of them both. Before doing so, however, it loops through itself until the minimum value becomes equal to 0 by resetting the minimum value to the maximum value % the minimum value.

  - 2c - Regarding the work of foo, let us assume that determining if a=0 or b=0 takes time c each. This means that every loop will be multiplied by 2c. The number of loops we progress is determined by how long it will take the minimum of our inputs to decrease to 0. Assuming the worst possible outcome, our minimum will decrease by 1 every loop, so it will take a number of loops equal to itself to reach 0. Our work, then, is __2c(min(a,b))__.
  Our span assumed that we have as many processors as we need to perform this work in parallel. Our conditional checks could be done in parallel, but the number of loops is still determined by our input, so our span is __c(min(a,b)__.

3. **Parallelism and recursion**

  - 3b - Work and span are both equal to n, the size of the input. There is no parallelism performed, and the amount of work done cleanly goes down each member of the function.

  - 3d - The recursive algorithm has work equal to n·log(n) and span equal to log(n). log(n) represents the number of splits down the binary tree assuming that, in the worst case scenario, the longest key string will be 1.

  - 3e - UNCERTAIN HOW DIFFERENT FROM 3D
  
4. **GCD**
"""