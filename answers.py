# -*- coding: utf-8 -*-
"""answers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A9PmY96g5c3f5coz3JUsLvgBM4jgThG-

# CMPS 6610 Problem Set 01
## Answers

**Name:** Adam Ledet

Place all written answers from `assignment-01.md` here for easier grading.

1. **Asymptotic notation**

  - 1a - Yes. As an example, let us look at every value of n from 1 to infinity, 2^(n+1) ≤ c·2^n. For any c value above 1, we will always get a true statement.

  - 1b - No. As a counter example, let us look at c=5 and every value of n. 2^(2^n) ≤ 5·2^(n). While this is true at n=1 and n=2, at any value of n=3 or larger, the statement is false.

  - 1c - No. Logs are always better performing than any exponent. Let us look at c=10 in this example. n^(1.01) ≤ 10·log(n)^2 for every value of n. At n < 3, our equation is false, but after this point, our exponent function dominates out log at every greater n.

  - 1d - Yes. This is the reverse of the previous problem and asks if n^1.01 asymptotically dominates c·log(n)^2. Any exponent will always outgrow any log.

  - 1e - No. We can rewrite sqrt(n) as n^(1/2). We know that log always outperforms (is faster) than any exponent, so log(n)^3 cannot dominate sqrt(n).

  - 1f - Yes. This is the reverse of the above problem. Exponents always dominate logs, so the statement must be true.

  - 1g - Logically, the intersection of *O* and Ω is the point at which both are equal. Representing *O* as g(n)≤f(n) and Ω as g(n)≥f(n), both statements are only true at THETA when the equations are equal. Our *o* and ω notations can be represented as g(n)<f(n) and g(n)>f(n) respectively. An intersection of these would be a number that is both greater than and less than another. For no real number can a number be both greater and less than another value. If no real number can be the solution, then the only solution is the empty set.

2. **SPARC to Python**

  - 2b - This function takes two inputs and ultimately returns the maximum of them both. Before doing so, however, it loops through itself until the minimum value becomes equal to 0 by resetting the minimum value to the maximum value % the minimum value.

  - 2c - Our work is determined by the full number of loops we progress through which is determined by the number of times we can fit the minimum of our inputs into the maximum of them recursively. In a worst-case scenario, our minimum value will decrease by 1 until it reaches 0 and we exit our loop. Our Work, therefore, is *O*min(a,b). Because our code is not done in parallel and instead runs everything in order, our Span is identical to our work.

3. **Parallelism and recursion**

  - 3b - Work and span are both equal to *O*(n), the size of the input. There is no parallelism performed, and the amount of work done cleanly goes down each member of the function.

  - 3d - The recursive algorithm involves splitting the list in half until it has only sections that contain homogenous characters. In a worst-case situation where no same characters are adjacent, it will perform the split log(n) times. If we split every character into its own list, we perform this calculation 2^(log(n)) times. This makes both our Work and our Span *O*(n) because the calculation has no parallelism.

  - 3e - If you add multithreading and parallelize the function, we can perform *O*(n) Work in *O*(log(n)) Span.
  
4. **GCD**
"""